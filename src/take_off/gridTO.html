<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <link rel="stylesheet" href="../styles.css">
  <style>
    /* take_off/gridTO.html */
    body[data-page="take-off-gridto"] { --bg:#0f172a; --panel:#111827; --ink:#e5e7eb; --muted:#9ca3af; --accent:#22c55e; --border:#1f2937; }
    body[data-page="take-off-gridto"] * {box-sizing:border-box}
    body[data-page="take-off-gridto"] {margin:0;font-family:ui-sans-serif,system-ui,-apple-system;background:var(--bg);color:var(--ink)}
    body[data-page="take-off-gridto"] .wrap {max-width:1150px;margin:32px auto;padding:0 10px}
    body[data-page="take-off-gridto"] h1 {font-size:1.2rem;margin:0 0 12px}
    body[data-page="take-off-gridto"] .card {background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:12px}
    body[data-page="take-off-gridto"] .row {display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    body[data-page="take-off-gridto"] .drop {display:grid;place-items:center;text-align:center;border:2px dashed #334155;border-radius:14px;padding:12px;min-height:140px;background:#0b1220;color:#9ca3af}
    body[data-page="take-off-gridto"] .drop.drag {border-color:var(--accent);color:var(--surface)}
    body[data-page="take-off-gridto"] input[type=file] {display:none}
    body[data-page="take-off-gridto"] button {background:var(--accent);color:#052e14;border:none;padding:9px 12px;border-radius:10px;font-weight:700;cursor:pointer}
    body[data-page="take-off-gridto"] button.secondary {background:#0b1220;color:#e5e7eb;border:1px solid var(--border)}
    body[data-page="take-off-gridto"] button[disabled] {opacity:.55;cursor:not-allowed}
    body[data-page="take-off-gridto"] select, body[data-page="take-off-gridto"] input[type=range] {background:#0b1220;color:#e5e7eb;border:1px solid var(--border);border-radius:8px;padding:6px 8px}
    body[data-page="take-off-gridto"] textarea {width:100%;min-height:220px;background:#0b1220;color:#e5e7eb;border:1px solid var(--border);border-radius:10px;padding:10px;font-family:ui-monospace,Menlo,monospace;white-space:pre}
    body[data-page="take-off-gridto"] canvas {max-width:100%;border-radius:10px;border:1px solid var(--border);background:#0b1220}
    body[data-page="take-off-gridto"] .kv {display:grid;gap:8px;grid-template-columns:repeat(auto-fit,minmax(220px,1fr))}
    body[data-page="take-off-gridto"] .pill {padding:6px 10px;border:1px solid var(--border);border-radius:999px;background:#0b1220}
    body[data-page="take-off-gridto"] .small {font-size:.9rem;color:#9ca3af}
    body[data-page="take-off-gridto"] #tbl {width:100%;border-collapse:collapse}
    body[data-page="take-off-gridto"] #tbl td, body[data-page="take-off-gridto"] #tbl th {border:1px solid var(--border);padding:6px 8px}
    body[data-page="take-off-gridto"] .canvas-wrap {position:relative;overflow:auto}
    body[data-page="take-off-gridto"] #overlay {position:absolute;left:0;top:0;background:transparent;border:none;z-index:1}
  </style>
  <title>Table OCR → Grid → XLSX</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
<!-- Tesseract.js -->
<script src="https://unpkg.com/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
<!-- OpenCV.js -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<!-- SheetJS (official CDN with correct MIME) -->
<script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/dist/xlsx.full.min.js" id="xlsx-script"></script>
</head>
<body data-page="take-off-gridto">
<div class="wrap">
  <h1>Table OCR → Grid → XLSX (offline)</h1>
  <div class="card">
    <div class="row">
      <span class="pill">Paste (Ctrl/Cmd-V) or use “Paste from Clipboard”</span>
      <span class="pill">Set Target rows/cols, drag grid nodes to align, then click “Extract Table”.</span>
    </div>

    <div id="drop" class="drop" tabindex="0">
      <div>
        <div style="font-weight:700;color:#e2e8f0">Drop an image here or click to select</div>
        <div class="small">Or click “Paste from Clipboard” (HTTPS/permission required)</div>
        <div style="height:8px"></div>
        <button id="chooseBtn">Choose Image</button>
        <button id="pasteBtn" class="secondary">Paste from Clipboard</button>
        <input id="file" type="file" accept="image/*" />
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <div id="canvasWrap" class="canvas-wrap" style="width:100%">
        <canvas id="preview" style="display:none"></canvas>
        <canvas id="overlay" style="display:none"></canvas>
      </div>
    </div>

    <hr style="border-color:#1f2937;margin:14px 0">

    <div class="kv">
      <div><label>Target rows</label>
        <input type="number" id="targetRows" min="0" value="0">
      </div>
      <div><label>Target columns</label>
        <input type="number" id="targetCols" min="0" value="0">
      </div>
    </div>

    <div class="row" style="margin-top:8px">
      <button id="extractBtn" disabled>Extract Table</button>
      <button id="xlsxBtn" disabled>Download .xlsx</button>
      <span id="status" class="small"></span>
    </div>

    <div class="row small">
      <span>Angle: <code id="angle">–</code></span>
      <span>Grid: <code id="grid">–</code></span>
      <span>Cells: <code id="cells">–</code></span>
      <span>SheetJS: <code id="sj">checking…</code></span>
    </div>

    <div class="row"><div style="width:100%;overflow:auto"><table id="tbl"></table></div></div>
  </div>
</div>

<script>
const prev = document.getElementById('preview');
const overlay = document.getElementById('overlay');
const canvasWrap = document.getElementById('canvasWrap');
const file = document.getElementById('file'), chooseBtn = document.getElementById('chooseBtn');
const pasteBtn = document.getElementById('pasteBtn'), drop = document.getElementById('drop');
const extractBtn = document.getElementById('extractBtn');
const xlsxBtn = document.getElementById('xlsxBtn');
const statusEl = document.getElementById('status');
const angleEl = document.getElementById('angle'), gridEl = document.getElementById('grid'), cellsEl = document.getElementById('cells');
const sjEl = document.getElementById('sj');
const tbl = document.getElementById('tbl');
const targetRows = document.getElementById('targetRows');
const targetCols = document.getElementById('targetCols');

let imageBitmap=null, lastAoa=null, matsCache=null;
let grid={xLines:[],yLines:[]}, dragging=null, overlayEventsBound=false;
let zoom=1, snapX=[], snapY=[];

function setBusy(s){ statusEl.textContent = s || '' }
function enable(on){ extractBtn.disabled=!on }
chooseBtn.onclick = ()=> file.click();
file.onchange = ()=> { if (file.files?.[0]) loadImage(file.files[0]) };
['dragenter','dragover'].forEach(ev=>drop.addEventListener(ev,e=>{e.preventDefault(); drop.classList.add('drag')}))
;['dragleave','drop'].forEach(ev=>drop.addEventListener(ev,e=>{e.preventDefault(); drop.classList.remove('drag')}))
drop.addEventListener('drop', e=>{ const f=e.dataTransfer.files?.[0]; if(f&&f.type.startsWith('image/')) loadImage(f); });
drop.addEventListener('click', ()=> file.click());
window.addEventListener('paste', e=>{
  const itms = e.clipboardData?.items||[]; for(const it of itms){ if(it.type?.startsWith('image/')){ loadImage(it.getAsFile()); break; } }
});
pasteBtn.onclick = async ()=>{
  if(navigator.clipboard?.read){ try{ const items=await navigator.clipboard.read();
    for(const item of items){ for(const type of item.types){ if(type.startsWith('image/')){ const b=await item.getType(type); await loadImage(b); return; } } }
    alert('No image on clipboard'); } catch{ alert('Clipboard blocked. Try Ctrl/Cmd-V.'); } }
  else alert('Clipboard API not supported. Use Ctrl/Cmd-V.');
}
sjEl.textContent = window.XLSX ? 'ok' : 'not loaded';
window.addEventListener('load', ()=> sjEl.textContent = window.XLSX ? 'ok' : 'not loaded');

targetRows.addEventListener('input', ()=> initGridFromTargets());
targetCols.addEventListener('input', ()=> initGridFromTargets());

const cvReady = new Promise(res=>{ (function tick(){ if(window.cv?.getBuildInformation) res(); else setTimeout(tick,50); })(); });

let ocrWorker=null, ocrWorkerInit=null;
async function getOcrWorker(){
  if(ocrWorker) return ocrWorker;
  if(!ocrWorkerInit){
    ocrWorkerInit = (async()=>{
      const w = await Tesseract.createWorker('eng');
      await w.setParameters({ tessedit_pageseg_mode: 6, user_defined_dpi: '220' });
      ocrWorker = w; return w;
    })();
  }
  return ocrWorkerInit;
}

async function loadImage(blob){
  imageBitmap = await createImageBitmap(blob);
  prev.style.display='none'; overlay.style.display='none';
  lastAoa=null; gridEl.textContent='–'; cellsEl.textContent='–'; angleEl.textContent='–';
  tbl.innerHTML='';
  enable(false); xlsxBtn.disabled=true; matsCache?.rot?.delete(); matsCache?.bw?.delete(); matsCache=null; zoom=1;
  await preprocess();
}

/* -------- Preprocess: upscale → grayscale → blur → threshold → deskew -------- */
async function preprocess(){
  await cvReady; if(!imageBitmap) return null; setBusy('Preprocessing…');
  // upscale first
  const maxSide = Math.max(imageBitmap.width, imageBitmap.height);
  const s = Math.max(1, Math.min(4, Math.round(1800 / maxSide)));
  const up = document.createElement('canvas'); up.width = imageBitmap.width*s; up.height = imageBitmap.height*s;
  up.getContext('2d').imageSmoothingEnabled = false;
  up.getContext('2d').drawImage(imageBitmap,0,0,up.width,up.height);

  const d = up.getContext('2d').getImageData(0,0,up.width,up.height);
  let src = cv.matFromImageData(d), gray=new cv.Mat(), blur=new cv.Mat(), bw=new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
  cv.GaussianBlur(gray, blur, new cv.Size(3,3), 0);
  // adaptive threshold inverted: lines/text become white
  cv.adaptiveThreshold(blur, bw, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY_INV, 15, 10);

  // deskew by Hough on edges
  let edges=new cv.Mat(); cv.Canny(blur, edges, 50, 150);
  let lines=new cv.Mat(); cv.HoughLinesP(edges, lines, 1, Math.PI/180, 140, 60, 6);
  let angles=[];
  for(let i=0;i<lines.rows;i++){ const p = lines.intPtr(i); const ang = Math.atan2(p[3]-p[1],p[2]-p[0]) * 180/Math.PI; if(Math.abs(ang)<30) angles.push(ang); }
  let angle=0; if(angles.length){ angles.sort((a,b)=>a-b); angle = angles.length%2? angles[(angles.length-1)/2] : 0.5*(angles[angles.length/2-1]+angles[angles.length/2]); }
  angleEl.textContent = angle.toFixed(2)+'°';

  let rot=new cv.Mat(); const center=new cv.Point(src.cols/2,src.rows/2);
  const M=cv.getRotationMatrix2D(center, angle, 1.0); const bb=rotSize(src.cols,src.rows,angle);
  M.doublePtr(0,2)[0]+= (bb.width/2 - center.x); M.doublePtr(1,2)[0]+= (bb.height/2 - center.y);
  cv.warpAffine(src, rot, M, new cv.Size(bb.width,bb.height), cv.INTER_LINEAR, cv.BORDER_REPLICATE);

  let gray2=new cv.Mat(), blur2=new cv.Mat(), bw2=new cv.Mat();
  cv.cvtColor(rot, gray2, cv.COLOR_RGBA2GRAY, 0);
  cv.GaussianBlur(gray2, blur2, new cv.Size(3,3), 0);
  // Otsu on upscaled often works even better after deskew:
  cv.threshold(blur2, bw2, 0, 255, cv.THRESH_BINARY_INV+cv.THRESH_OTSU);

  showMat(rot, prev); prev.style.display='block';
  overlay.width = prev.width; overlay.height = prev.height; overlay.style.display='block';
  matsCache?.rot?.delete(); matsCache?.bw?.delete();
  src.delete(); gray.delete(); blur.delete(); bw.delete(); edges.delete(); lines.delete(); M.delete(); gray2.delete(); blur2.delete();

  setBusy('');
  matsCache={ rot, bw:bw2 };
  computeSnapCandidates(matsCache.bw);
  bindOverlayEventsOnce();
  applyZoom();
  initGridFromTargets();
  enable(true);
  return matsCache;
}

/* -------- Overlay grid (draggable nodes) -------- */
function bindOverlayEventsOnce(){ if(overlayEventsBound) return; overlayEventsBound=true;
  overlay.addEventListener('pointerdown', onOverlayPointerDown);
  overlay.addEventListener('dblclick', onOverlayDblClick);
  overlay.addEventListener('contextmenu', onOverlayContextMenu);
  window.addEventListener('pointermove', onOverlayPointerMove);
  window.addEventListener('pointerup', onOverlayPointerUp);
  canvasWrap.addEventListener('wheel', onWheel, {passive:false});
}
function initGridFromTargets(){ if(!matsCache?.rot) return; const w=matsCache.rot.cols, h=matsCache.rot.rows;
  const r = Math.max(0, parseInt(targetRows.value||'0',10)||0);
  const c = Math.max(0, parseInt(targetCols.value||'0',10)||0);
  const yLines = r>0 ? Array.from({length:r+1}, (_,i)=> Math.round(i*(h-1)/r)) : [0,h-1];
  const xLines = c>0 ? Array.from({length:c+1}, (_,i)=> Math.round(i*(w-1)/c)) : [0,w-1];
  grid={xLines:[...new Set(xLines)].sort((a,b)=>a-b), yLines:[...new Set(yLines)].sort((a,b)=>a-b)};
  drawOverlay(); gridEl.textContent = `${grid.yLines.length-1}×${grid.xLines.length-1}`;
}
function drawOverlay(){ if(!overlay||!matsCache?.rot) return; const ctx=overlay.getContext('2d');
  overlay.width = matsCache.rot.cols; overlay.height = matsCache.rot.rows;
  ctx.clearRect(0,0,overlay.width,overlay.height);
  ctx.save(); ctx.globalAlpha=0.8; ctx.strokeStyle='#22c55e'; ctx.lineWidth=1;
  for(const x of grid.xLines){ ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,overlay.height); ctx.stroke(); }
  for(const y of grid.yLines){ ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(overlay.width,y+0.5); ctx.stroke(); }
  ctx.globalAlpha=1; ctx.fillStyle='#22c55e';
  for(let i=0;i<grid.yLines.length;i++){
    for(let j=0;j<grid.xLines.length;j++){
      const x=grid.xLines[j], y=grid.yLines[i]; ctx.beginPath(); ctx.arc(x,y,4,0,Math.PI*2); ctx.fill();
    }
  }
  ctx.restore();
  gridEl.textContent = `${grid.yLines.length-1}×${grid.xLines.length-1}`;
}
function clientToCanvas(e){ const r=overlay.getBoundingClientRect(); const sx=overlay.width/r.width, sy=overlay.height/r.height; return {x:(e.clientX-r.left)*sx, y:(e.clientY-r.top)*sy}; }
function hitTestNode(x,y){ let best=null, bestD2=Infinity; const R=12; const R2=R*R;
  for(let i=0;i<grid.yLines.length;i++){
    for(let j=0;j<grid.xLines.length;j++){
      const dx=x-grid.xLines[j], dy=y-grid.yLines[i]; const d2=dx*dx+dy*dy; if(d2<R2 && d2<bestD2){ bestD2=d2; best={i,j}; }
    }
  }
  return best;
}
function onOverlayPointerDown(e){ if(!overlay||overlay.style.display==='none') return; const p=clientToCanvas(e); if(e.altKey){ deleteNearestLineAt(p.x,p.y); e.preventDefault(); return; } const hit=hitTestNode(p.x,p.y); if(hit){ dragging={i:hit.i,j:hit.j}; e.preventDefault(); overlay.setPointerCapture?.(e.pointerId); } }
function onOverlayPointerMove(e){ if(!dragging) return; const p=clientToCanvas(e);
  const i=dragging.i, j=dragging.j; const minX= (j>0?grid.xLines[j-1]+2:0), maxX=(j<grid.xLines.length-1?grid.xLines[j+1]-2:overlay.width-1); const minY=(i>0?grid.yLines[i-1]+2:0), maxY=(i<grid.yLines.length-1?grid.yLines[i+1]-2:overlay.height-1);
  let nx=Math.max(minX, Math.min(maxX, Math.round(p.x)));
  let ny=Math.max(minY, Math.min(maxY, Math.round(p.y)));
  nx = snapValue(nx, snapX, 6); ny = snapValue(ny, snapY, 6);
  grid.xLines[j]=Math.max(minX, Math.min(maxX, nx));
  grid.yLines[i]=Math.max(minY, Math.min(maxY, ny));
  drawOverlay();
}
function onOverlayPointerUp(e){ if(dragging){ dragging=null; overlay.releasePointerCapture?.(e.pointerId); } }

function onOverlayDblClick(e){ if(!overlay||overlay.style.display==='none') return; const p=clientToCanvas(e); const dxIdx=nearestIndex(grid.xLines,p.x); const dyIdx=nearestIndex(grid.yLines,p.y); const dX=Math.abs(grid.xLines[dxIdx]-p.x); const dY=Math.abs(grid.yLines[dyIdx]-p.y); if(dX<dY) insertVerticalAt(p.x); else insertHorizontalAt(p.y); }
function onOverlayContextMenu(e){ e.preventDefault(); const p=clientToCanvas(e); deleteNearestLineAt(p.x,p.y); }
function onWheel(e){ if(!(e.ctrlKey||e.metaKey)) return; e.preventDefault(); const rect=canvasWrap.getBoundingClientRect(); const mx=e.clientX-rect.left, my=e.clientY-rect.top; const cx=(canvasWrap.scrollLeft+mx)/zoom, cy=(canvasWrap.scrollTop+my)/zoom; const factor=e.deltaY<0?1.1:0.9; const newZoom=Math.max(0.25, Math.min(4, zoom*factor)); zoom=newZoom; applyZoom(); canvasWrap.scrollLeft=cx*zoom - mx; canvasWrap.scrollTop=cy*zoom - my; }
function applyZoom(){ if(!matsCache?.rot) return; const w=matsCache.rot.cols, h=matsCache.rot.rows; prev.style.width=(w*zoom)+'px'; prev.style.height=(h*zoom)+'px'; overlay.style.width=(w*zoom)+'px'; overlay.style.height=(h*zoom)+'px'; }
function nearestIndex(arr, v){ let bi=0, bd=Infinity; for(let i=0;i<arr.length;i++){ const d=Math.abs(arr[i]-v); if(d<bd){ bd=d; bi=i; } } return bi; }
function insertVerticalAt(x){ const arr=grid.xLines; let i=0; while(i<arr.length && arr[i]<x) i++; const lo=i-1, hi=i; if(lo<0||hi>=arr.length) return; const minSep=3; const val=Math.max(arr[lo]+minSep, Math.min(arr[hi]-minSep, Math.round(x))); if(val<=arr[lo]+minSep || val>=arr[hi]-minSep) return; arr.splice(hi,0,val); drawOverlay(); }
function insertHorizontalAt(y){ const arr=grid.yLines; let i=0; while(i<arr.length && arr[i]<y) i++; const lo=i-1, hi=i; if(lo<0||hi>=arr.length) return; const minSep=3; const val=Math.max(arr[lo]+minSep, Math.min(arr[hi]-minSep, Math.round(y))); if(val<=arr[lo]+minSep || val>=arr[hi]-minSep) return; arr.splice(hi,0,val); drawOverlay(); }
function deleteNearestLineAt(x,y){ const j=nearestIndex(grid.xLines,x); const i=nearestIndex(grid.yLines,y); const dX=Math.abs(grid.xLines[j]-x), dY=Math.abs(grid.yLines[i]-y); if(dX<dY){ if(j>0 && j<grid.xLines.length-1){ grid.xLines.splice(j,1); drawOverlay(); } } else { if(i>0 && i<grid.yLines.length-1){ grid.yLines.splice(i,1); drawOverlay(); } } }
function computeSnapCandidates(bw){ const xs=project(bw,'y'); const ys=project(bw,'x'); snapX=findPeaks(xs,0.45,8); snapY=findPeaks(ys,0.45,8); }
function findPeaks(arr, frac, minGap){ const max=Math.max(...arr)||1; const th=max*frac; const idx=[]; for(let i=1;i<arr.length-1;i++){ if(arr[i]>=th && arr[i]>=arr[i-1] && arr[i]>=arr[i+1]) idx.push(i); } return mergeClose(idx, minGap); }
function snapValue(v, cands, tol){ let best=v, bd=tol+1; for(const q of cands){ const d=Math.abs(q-v); if(d<=tol && d<bd){ bd=d; best=q; } } return best; }

/* -------- OCR per cell -------- */
async function ocrCells(rot, xLines, yLines){
  const pad=2, rows=yLines.length-1, cols=xLines.length-1;
  const aoa = Array.from({length:rows},()=>Array(cols).fill(''));
  const tmp = document.createElement('canvas'), tctx=tmp.getContext('2d');
  const worker = await getOcrWorker();

  // draw once
  const rgba = rot.clone();
  const id=new ImageData(new Uint8ClampedArray(rgba.data), rot.cols, rot.rows);
  const master=document.createElement('canvas'); master.width=rot.cols; master.height=rot.rows;
  master.getContext('2d').putImageData(id,0,0);

  const total=rows*cols; let count=0; setBusy(`OCR ${total} cells…`);
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const x0=Math.max(0,xLines[c]+pad), x1=Math.min(rot.cols,xLines[c+1]-pad);
      const y0=Math.max(0,yLines[r]+pad), y1=Math.min(rot.rows,yLines[r+1]-pad);
      const w=Math.max(1,x1-x0), h=Math.max(1,y1-y0);
      tmp.width=w; tmp.height=h; tctx.drawImage(master,x0,y0,w,h,0,0,w,h);
      const { data } = await worker.recognize(tmp);
      aoa[r][c]=(data.text||'').replace(/\s+/g,' ').trim();
      if(++count%6===0) setBusy(`OCR ${count}/${total} cells…`);
    }
  }
  rgba.delete(); setBusy(''); cellsEl.textContent=String(total);
  return aoa;
}

/* -------- Buttons -------- */
extractBtn.onclick = async()=>{
  enable(false);
  try{
    const m = matsCache || await preprocess();
    const xLines = [...new Set(grid.xLines)].sort((a,b)=>a-b);
    const yLines = [...new Set(grid.yLines)].sort((a,b)=>a-b);
    if(xLines.length<2 || yLines.length<2){ setBusy('Define at least 1 row and 1 column.'); enable(true); return; }
    const aoa = await ocrCells(m.rot, xLines, yLines);
    lastAoa=aoa; xlsxBtn.disabled=!window.XLSX||!aoa.length;
    renderTable(aoa);
  } catch(e){ setBusy('Error: '+(e?.message||e)); console.error(e); }
  finally{ enable(true); }
};
xlsxBtn.onclick = ()=>{ if(!lastAoa||!lastAoa.length||!window.XLSX) return; const wb=XLSX.utils.book_new(); const ws=XLSX.utils.aoa_to_sheet(lastAoa); XLSX.utils.book_append_sheet(wb,ws,'Table'); XLSX.writeFile(wb,'table.xlsx'); };

/* -------- Utility -------- */
function showMat(mat,cnv){ cnv.width=mat.cols; cnv.height=mat.rows; const ctx=cnv.getContext('2d'); const img=new ImageData(new Uint8ClampedArray(mat.data),mat.cols,mat.rows); ctx.putImageData(img,0,0); }
function rotSize(w,h,a){ const r=Math.abs(a)*Math.PI/180, c=Math.cos(r), s=Math.sin(r); return {width:Math.round(h*s+w*c), height:Math.round(h*c+w*s)} }
function project(mat,axis){ let reduced=new cv.Mat(); const dim=(axis==='x')?1:0; cv.reduce(mat,reduced,dim,cv.REDUCE_SUM,cv.CV_32F); const len=(axis==='x')?mat.rows:mat.cols; const arr=[]; for(let i=0;i<len;i++) arr.push(reduced.floatAt(i,0)); reduced.delete(); return arr; }
function mergeClose(a,d){ if(!a.length) return []; a.sort((x,y)=>x-y); const out=[a[0]]; for(let i=1;i<a.length;i++){ if(a[i]-out[out.length-1]<=d) out[out.length-1]=Math.round((out[out.length-1]+a[i])/2); else out.push(a[i]); } return out; }
function htmlEsc(s){ return String(s||'').replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
function renderTable(aoa){ if(!tbl) return; tbl.innerHTML = (aoa&&aoa.length)? '<tbody>'+aoa.map(r=>'<tr>'+r.map(s=>'<td>'+htmlEsc(s)+'</td>').join('')+'</tr>').join('')+'</tbody>' : ''; }
 
</script>
</body>
</html>
