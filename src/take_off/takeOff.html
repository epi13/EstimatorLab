<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <link rel="stylesheet" href="../styles.css">
  <style>
    /* Take-off / blueprint viewer layout overrides */
    body[data-page="take-off-takeoff"] {
      margin: 0;
      min-height: 100vh;
      --takeoff-gutter: clamp(0.9rem, 1.8vw, 1.4rem);
      --takeoff-gap: var(--takeoff-gutter);
      padding: var(--takeoff-gutter);
      display: flex;
      flex-direction: column;
    }

    body[data-page="take-off-takeoff"] .takeoff-shell {
      display: flex;
      flex-direction: column;
      gap: var(--takeoff-gap);
      min-height: calc(100vh - (var(--takeoff-gutter) * 2));
      flex: 1 1 auto;
    }

    /* Disable the default centered max-width for this full-window app */
    body[data-page="take-off-takeoff"] > *:not(script):not(style) {
      max-width: none;
      margin: 0;
    }

    /* Topbar spans full width and stays visible */
    body[data-page="take-off-takeoff"] .topbar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: calc(var(--takeoff-gap) * 0.6);
      padding: calc(var(--takeoff-gap) * 0.6) var(--takeoff-gutter);
      background: transparent;
      position: sticky;
      top: var(--takeoff-gutter);
      z-index: 60;
    }

    body[data-page="take-off-takeoff"] .topbar--compact {
      gap: calc(var(--takeoff-gap) * 0.5);
      padding: calc(var(--takeoff-gap) * 0.5) var(--takeoff-gutter);
    }

    /* Main area: side panel + viewer */
    body[data-page="take-off-takeoff"] .wrap {
      display: flex;
      gap: var(--takeoff-gap);
      flex: 1 1 auto;
      padding: var(--takeoff-gutter);
      box-sizing: border-box;
      align-items: stretch;
      min-height: 0;
    }

    body[data-page="take-off-takeoff"] .wrap--compact {
      gap: var(--takeoff-gap);
      padding: var(--takeoff-gutter);
    }

    /* Left side panel fixed-ish */
    body[data-page="take-off-takeoff"] .panel {
      width: 320px;
      max-width: 35%;
      min-width: 260px;
      overflow: auto;
      background: var(--surface);
      border-radius: 12px;
      padding: 1rem;
      box-shadow: var(--shadow-soft);
    }

    /* Viewer should take remaining space and allow scrolling */
    body[data-page="take-off-takeoff"] .viewer {
      flex: 1 1 auto;
      min-width: 0; /* allow flex child to shrink properly */
      min-height: 0;
      background: transparent;
      overflow: auto;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    body[data-page="take-off-takeoff"] .canvas-stack {
      display: inline-block;
      max-width: 100%;
      height: auto;
    }

    body[data-page="take-off-takeoff"] .hint { text-align:center; padding: 1rem; }

    /* take_off/takeOff.html */
    body[data-page="take-off-takeoff"] {
      --bg-base: #020617;
      --bg-glow: rgba(37, 99, 235, 0.28);
      --bg-glow-secondary: rgba(16, 185, 129, 0.22);
      --panel: rgba(12, 20, 33, 0.82);
      --panel-solid: #0f172a;
      --panel-soft: rgba(12, 23, 42, 0.68);
      --ink: #f1f5f9;
      --muted: #9fb1d3;
      --brand: #60a5fa;
      --brand-strong: #38bdf8;
      --warn: #facc15;
      --danger: #f87171;
      --shadow-lg: 0 28px 60px -35px rgba(5, 16, 32, 0.82);
      --shadow-sm: 0 16px 36px -32px rgba(8, 25, 56, 0.8);
      --radius-lg: 22px;
    }

    body[data-page="take-off-takeoff"] {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      gap: clamp(0.85rem, 1.8vw, 1.4rem);
      padding: clamp(0.85rem, 1.8vw, 1.3rem) clamp(1.1rem, 3.5vw, 2.4rem) clamp(1.2rem, 2.6vw, 2.4rem);
      background:
        radial-gradient(circle at 12% 8%, var(--bg-glow), transparent 55%),
        radial-gradient(circle at 88% 16%, var(--bg-glow-secondary), transparent 62%),
        linear-gradient(180deg, #01030c 0%, var(--bg-base) 55%, #01030c 100%);
      background-attachment: fixed;
      color: var(--ink);
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif;
    }

    body[data-page="take-off-takeoff"] .topbar,
    body[data-page="take-off-takeoff"] main.wrap {
      width: min(1500px, 100%);
      margin-inline: auto;
    }

    body[data-page="take-off-takeoff"] .topbar {
      position: sticky;
      top: clamp(0.5rem, 1.2vw, 0.9rem);
      z-index: 30;
      display: flex;
      flex-direction: column;
      gap: clamp(0.35rem, 1vw, 0.65rem);
      padding: clamp(0.45rem, 1vw, 0.75rem) clamp(0.6rem, 1.6vw, 1rem);
      border-radius: 16px;
      background: linear-gradient(140deg, rgba(13, 22, 38, 0.92), rgba(7, 14, 28, 0.88));
      border: 1px solid rgba(148, 163, 184, 0.22);
      box-shadow: var(--shadow-lg);
      backdrop-filter: blur(18px);
    }

    body[data-page="take-off-takeoff"] .topbar__row {
      display: flex;
      flex-wrap: wrap;
      gap: clamp(0.45rem, 1.2vw, 0.75rem);
      align-items: stretch;
      justify-content: space-between;
    }

    body[data-page="take-off-takeoff"] .topbar__row--layout {
      align-items: stretch;
      gap: clamp(0.55rem, 1.3vw, 0.8rem);
    }

    body[data-page="take-off-takeoff"] .topbar__row--tools {
      align-items: stretch;
    }

    body[data-page="take-off-takeoff"] .brand {
      display: flex;
      align-items: center;
      gap: clamp(0.4rem, 1.1vw, 0.65rem);
      color: var(--ink);
    }

    body[data-page="take-off-takeoff"] .brand-icon {
      display: grid;
      place-items: center;
      width: 38px;
      height: 38px;
      border-radius: 12px;
      background: radial-gradient(circle at 30% 30%, rgba(96, 165, 250, 0.25), rgba(56, 189, 248, 0.18));
      box-shadow: 0 18px 32px -24px rgba(37, 99, 235, 0.75);
      font-size: 1.2rem;
    }

    body[data-page="take-off-takeoff"] .brand-copy h1 {
      margin: 0;
      font-size: clamp(0.95rem, 2vw, 1.15rem);
      letter-spacing: 0.02em;
    }

    body[data-page="take-off-takeoff"] .brand-copy p {
      margin: 0.1rem 0 0;
      font-size: 0.75rem;
      color: var(--muted);
      max-width: 32ch;
    }

    body[data-page="take-off-takeoff"] .topbar__clusters {
      display: grid;
      flex: 1 1 auto;
      gap: clamp(0.4rem, 1.1vw, 0.6rem);
      grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
      align-items: stretch;
    }

    body[data-page="take-off-takeoff"] .pill {
      display: flex;
      align-items: center;
      gap: clamp(0.3rem, 0.9vw, 0.6rem);
      padding: clamp(0.3rem, 0.8vw, 0.6rem) clamp(0.5rem, 1vw, 0.8rem);
      border-radius: 14px;
      background: var(--panel);
      border: 1px solid rgba(148, 163, 184, 0.18);
      box-shadow: var(--shadow-sm);
      min-height: 38px;
    }

    body[data-page="take-off-takeoff"] .pill__stack {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
      min-width: 120px;
    }

    body[data-page="take-off-takeoff"] .pill--file {
      flex: 1 1 240px;
      align-items: stretch;
    }

    body[data-page="take-off-takeoff"] .pill--file input[type="file"] {
      width: 100%;
      background: rgba(15, 23, 42, 0.85);
      color: var(--ink);
      border: 1px dashed rgba(148, 163, 184, 0.35);
      border-radius: 10px;
      padding: 0.35rem 0.5rem;
      cursor: pointer;
    }

    body[data-page="take-off-takeoff"] .pill--file input[type="file"]::file-selector-button {
      margin-right: 0.75rem;
      border: none;
      border-radius: 8px;
      background: linear-gradient(135deg, var(--brand), var(--brand-strong));
      color: #010b19;
      padding: 0.35rem 0.75rem;
      font-weight: 600;
      cursor: pointer;
      transition: filter 0.2s ease;
    }

    body[data-page="take-off-takeoff"] .pill--file input[type="file"]::file-selector-button:hover {
      filter: brightness(1.05);
    }

    body[data-page="take-off-takeoff"] .pill--file .file-name {
      align-self: center;
      padding: 0.25rem 0.55rem;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.12);
      color: var(--muted);
      white-space: nowrap;
      max-width: 180px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    body[data-page="take-off-takeoff"] .pill--file .tool {
      align-self: center;
    }

    body[data-page="take-off-takeoff"] .pill--nav,
    body[data-page="take-off-takeoff"] .pill--zoom,
    body[data-page="take-off-takeoff"] .pill--export {
      flex: 1 1 200px;
      justify-content: center;
    }

    body[data-page="take-off-takeoff"] .pill--tools {
      flex: 1 1 auto;
      flex-wrap: wrap;
      justify-content: flex-start;
      align-items: center;
      gap: 0.2rem;
      padding: clamp(0.25rem, 0.7vw, 0.45rem) clamp(0.45rem, 0.9vw, 0.7rem);
      min-height: 42px;
    }

    body[data-page="take-off-takeoff"] .pill--units {
      flex: 0 0 auto;
      gap: 0.4rem;
    }

    body[data-page="take-off-takeoff"] .tool {
      appearance: none;
      border: none;
      background: transparent;
      color: var(--ink);
      font-weight: 600;
      font-size: 0.8rem;
      padding: 0.25rem 0.45rem;
      border-radius: 999px;
      transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease, border 0.2s ease;
      cursor: pointer;
    }

    body[data-page="take-off-takeoff"] .tool:hover {
      background: rgba(96, 165, 250, 0.16);
    }

    body[data-page="take-off-takeoff"] .tool:focus-visible {
      outline: 2px solid var(--brand);
      outline-offset: 2px;
    }

    body[data-page="take-off-takeoff"] .tool.active {
      background: linear-gradient(135deg, var(--brand), var(--brand-strong));
      color: #021024;
      box-shadow: 0 12px 28px -18px rgba(56, 189, 248, 0.85);
    }

    body[data-page="take-off-takeoff"] .tool.ghost {
      border: 1px solid rgba(148, 163, 184, 0.28);
      background: rgba(148, 163, 184, 0.05);
      color: var(--muted);
    }

    body[data-page="take-off-takeoff"] .tool.ghost:hover {
      color: var(--ink);
      border-color: rgba(148, 163, 184, 0.45);
      background: rgba(148, 163, 184, 0.12);
    }

    body[data-page="take-off-takeoff"] .small {
      font-size: 0.78rem;
      color: var(--muted);
    }

    body[data-page="take-off-takeoff"] .num {
      font-variant-numeric: tabular-nums;
    }

    body[data-page="take-off-takeoff"] select,
    body[data-page="take-off-takeoff"] input[type="number"],
    body[data-page="take-off-takeoff"] input[type="text"] {
      background: rgba(15, 23, 42, 0.85);
      color: var(--ink);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 12px;
      padding: 0.45rem 0.6rem;
      min-width: 0;
    }

    body[data-page="take-off-takeoff"] select:focus-visible,
    body[data-page="take-off-takeoff"] input[type="number"]:focus-visible,
    body[data-page="take-off-takeoff"] input[type="text"]:focus-visible {
      outline: 2px solid var(--brand);
      outline-offset: 2px;
      border-color: var(--brand);
    }

    body[data-page="take-off-takeoff"] main.wrap {
      flex: 1;
      min-height: 0;
      display: grid;
      grid-template-columns: minmax(280px, 320px) minmax(0, 1fr);
      gap: clamp(1rem, 2.5vw, 1.8rem);
      padding: clamp(1rem, 2.5vw, 1.8rem);
      border-radius: var(--radius-lg);
      background: linear-gradient(165deg, rgba(11, 18, 32, 0.94), rgba(8, 15, 28, 0.88));
      border: 1px solid rgba(148, 163, 184, 0.2);
      box-shadow: var(--shadow-lg);
    }

    body[data-page="take-off-takeoff"] #side {
      display: flex;
      flex-direction: column;
      gap: clamp(1rem, 2vw, 1.4rem);
    }

    body[data-page="take-off-takeoff"] .panel {
      background: var(--panel-solid);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 18px;
      padding: clamp(1rem, 2vw, 1.35rem);
      box-shadow: var(--shadow-sm);
      display: flex;
      flex-direction: column;
      gap: clamp(0.85rem, 1.5vw, 1.1rem);
      min-height: 0;
      overflow: hidden;
    }

    body[data-page="take-off-takeoff"] .panel-section {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    body[data-page="take-off-takeoff"] .panel-section + .panel-section {
      border-top: 1px solid rgba(148, 163, 184, 0.12);
      padding-top: 0.9rem;
    }

    body[data-page="take-off-takeoff"] .panel-section.grow {
      flex: 1;
      min-height: 0;
    }

    body[data-page="take-off-takeoff"] .panel h3 {
      margin: 0;
      font-size: 1rem;
      color: #dbeafe;
      letter-spacing: 0.01em;
    }

    body[data-page="take-off-takeoff"] .kvs {
      display: grid;
      grid-template-columns: 1fr auto;
      row-gap: 0.4rem;
      column-gap: 0.65rem;
      font-size: 0.9rem;
    }

    body[data-page="take-off-takeoff"] .kvs .k {
      color: var(--muted);
    }

    body[data-page="take-off-takeoff"] .instructions {
      margin: 0;
      padding-left: 1.2rem;
      display: grid;
      gap: 0.35rem;
      line-height: 1.5;
      color: rgba(226, 232, 240, 0.92);
    }

    body[data-page="take-off-takeoff"] .row.row-spaced {
      gap: 0.65rem;
    }

    body[data-page="take-off-takeoff"] .muted-note {
      margin-top: 0.2rem;
      background: rgba(148, 163, 184, 0.08);
      border-radius: 12px;
      padding: 0.6rem 0.75rem;
    }

    body[data-page="take-off-takeoff"] .list {
      flex: 1;
      min-height: 0;
      overflow: auto;
      border-top: 1px dashed rgba(148, 163, 184, 0.2);
      margin-top: 0.4rem;
      padding-top: 0.75rem;
    }

    body[data-page="take-off-takeoff"] .note {
      color: var(--muted);
    }

    body[data-page="take-off-takeoff"] .viewer {
      position: relative;
      border-radius: var(--radius-lg);
      overflow: auto;
      border: 1px solid rgba(148, 163, 184, 0.18);
      background:
        radial-gradient(circle at 50% 30%, rgba(56, 189, 248, 0.12), transparent 58%),
        rgba(5, 11, 22, 0.92);
      box-shadow: var(--shadow-lg);
      min-height: 0;
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      padding: clamp(0.85rem, 2.2vw, 1.5rem);
    }

    body[data-page="take-off-takeoff"] .canvas-stack {
      position: relative;
      display: inline-block;
    }

    body[data-page="take-off-takeoff"] canvas {
      display: block;
    }

    body[data-page="take-off-takeoff"] #overlay {
      position: absolute;
      left: 0;
      top: 0;
      pointer-events: auto;
    }

    body[data-page="take-off-takeoff"] #labels {
      position: absolute;
      left: 0;
      top: 0;
      pointer-events: none;
    }

    body[data-page="take-off-takeoff"] .hint {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: rgba(15, 23, 42, 0.88);
      padding: 0.75rem 1rem;
      border-radius: 16px;
      font-size: 0.9rem;
      color: var(--muted);
      text-align: center;
      box-shadow: 0 18px 40px -28px rgba(15, 23, 42, 0.9);
      max-width: 260px;
    }

    body[data-page="take-off-takeoff"] .btn {
      background: linear-gradient(135deg, var(--brand), var(--brand-strong));
      border: none;
      border-radius: 12px;
      color: #020b1a;
      font-weight: 700;
      padding: 0.55rem 0.85rem;
      cursor: pointer;
      box-shadow: 0 18px 36px -28px rgba(56, 189, 248, 0.9);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    body[data-page="take-off-takeoff"] .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 20px 42px -28px rgba(56, 189, 248, 0.95);
    }

    body[data-page="take-off-takeoff"] .btn.secondary {
      background: transparent;
      color: var(--muted);
      border: 1px solid rgba(148, 163, 184, 0.32);
      box-shadow: none;
    }

    body[data-page="take-off-takeoff"] .btn.secondary:hover {
      color: var(--ink);
      border-color: rgba(148, 163, 184, 0.5);
    }

    body[data-page="take-off-takeoff"] .btn.warn {
      background: linear-gradient(135deg, #fde047, var(--warn));
      color: #1a1500;
    }

    body[data-page="take-off-takeoff"] .btn.danger {
      background: linear-gradient(135deg, #fb7185, var(--danger));
      color: #200;
    }

    body[data-page="take-off-takeoff"] .btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    body[data-page="take-off-takeoff"] .badge {
      font-size: 0.75rem;
      background: rgba(148, 163, 184, 0.16);
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      color: #e2e8f0;
    }

    body[data-page="take-off-takeoff"] .badge.mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    }

    body[data-page="take-off-takeoff"] .modal {
      position: fixed;
      inset: 0;
      background: rgba(2, 6, 23, 0.72);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 40;
      backdrop-filter: blur(6px);
    }

    body[data-page="take-off-takeoff"] .modal .sheet {
      background: var(--panel-solid);
      border: 1px solid rgba(148, 163, 184, 0.24);
      border-radius: 20px;
      min-width: 320px;
      max-width: 92vw;
      padding: 1.15rem 1.3rem;
      box-shadow: var(--shadow-lg);
    }

    body[data-page="take-off-takeoff"] .sheet h4 {
      margin: 0;
      font-size: 1rem;
      color: #e2e8f0;
    }

    body[data-page="take-off-takeoff"] .row {
      display: flex;
      gap: 0.65rem;
      align-items: center;
      margin: 0.35rem 0;
    }

    body[data-page="take-off-takeoff"] .grow {
      flex: 1;
    }

    body[data-page="take-off-takeoff"] .row-between {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.85rem;
    }

    body[data-page="take-off-takeoff"] .muted {
      color: var(--muted);
    }

    @media (max-width: 1200px) {
      body[data-page="take-off-takeoff"] .pill-group {
        justify-content: flex-start;
      }

      body[data-page="take-off-takeoff"] .pill--file {
        flex: 1 1 100%;
      }
    }

    @media (max-width: 1024px) {
      body[data-page="take-off-takeoff"] main.wrap {
        grid-template-columns: minmax(0, 1fr);
        grid-template-rows: auto minmax(0, 1fr);
      }

      body[data-page="take-off-takeoff"] .viewer {
        min-height: 52vh;
      }

      body[data-page="take-off-takeoff"] .topbar__row--secondary {
        flex-direction: column;
        align-items: stretch;
      }

      body[data-page="take-off-takeoff"] .pill--units {
        justify-content: center;
      }
    }

    @media (max-width: 780px) {
      body[data-page="take-off-takeoff"] .topbar {
        position: static;
      }

      body[data-page="take-off-takeoff"] .pill--nav,
      body[data-page="take-off-takeoff"] .pill--zoom,
      body[data-page="take-off-takeoff"] .pill--export {
        flex: 1 1 100%;
      }
    }

    @media (max-width: 560px) {
      body[data-page="take-off-takeoff"] {
        padding: 1rem;
      }

      body[data-page="take-off-takeoff"] .topbar,
      body[data-page="take-off-takeoff"] main.wrap {
        width: 100%;
      }

      body[data-page="take-off-takeoff"] .pill {
        flex-direction: column;
        align-items: stretch;
        gap: 0.5rem;
      }

      body[data-page="take-off-takeoff"] .pill--file .file-name {
        align-self: stretch;
        text-align: center;
      }

      body[data-page="take-off-takeoff"] .pill--tools {
        min-height: 0;
      }

      body[data-page="take-off-takeoff"] main.wrap {
        padding: 1rem;
      }
    }
  </style>

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Blueprint Measure</title>
  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script>
    // Configure worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
  </script>
</head>
<body data-page="take-off-takeoff">
  <div class="takeoff-shell">
    <header class="topbar topbar--compact" role="banner">
      <div class="topbar__row topbar__row--layout">
        <div class="brand" aria-label="Blueprint Measure">
          <span class="brand-icon" aria-hidden="true">📐</span>
          <div class="brand-copy">
            <h1>Blueprint Measure</h1>
            <p>Calibrate drawings, trace geometry, and capture precise takeoffs.</p>
          </div>
        </div>
        <div class="topbar__clusters" aria-label="Primary controls">
          <div class="pill pill--file">
            <div class="pill__stack">
              <label class="small" for="file">Upload PDF</label>
              <input id="file" type="file" accept="application/pdf" />
            </div>
            <span id="fileName" class="file-name small">No document loaded</span>
            <button id="demoBtn" class="tool ghost" type="button" title="Load demo PDF">Demo</button>
          </div>
          <div class="pill pill--nav" aria-label="Page navigation">
            <button class="tool" id="prev" type="button" title="Previous page">◀</button>
            <span class="small">Page <span id="pageNum" class="num">–</span>/<span id="pageCount" class="num">–</span></span>
            <button class="tool" id="next" type="button" title="Next page">▶</button>
          </div>
          <div class="pill pill--zoom" aria-label="Zoom controls">
            <button class="tool" id="zoomOut" type="button" title="Zoom out">–</button>
            <span class="small num" id="zoomLbl">100%</span>
            <button class="tool" id="zoomIn" type="button" title="Zoom in">+</button>
            <button class="tool ghost" id="zoomReset" type="button" title="Reset zoom">Reset</button>
          </div>
          <div class="pill pill--export" aria-label="Export">
            <button class="tool" id="exportJson" type="button">⇩ Export JSON</button>
            <button class="tool" id="exportPng" type="button">📸 Snapshot</button>
          </div>
        </div>
      </div>
      <div class="topbar__row topbar__row--tools">
        <div class="pill pill--tools" id="toolGroup" aria-label="Measurement tools">
          <button class="tool" data-tool="pan" type="button" title="Pan (hold Space to pan)">🖐️ Pan</button>
          <button class="tool" data-tool="calibrate" type="button" title="Calibrate scale">🎯 Calibrate</button>
          <button class="tool" data-tool="line" type="button" title="Measure line">📏 Line</button>
          <button class="tool" data-tool="area" type="button" title="Measure polygon area">▱ Area</button>
          <button class="tool" id="undo" type="button" title="Undo last point">↶ Undo</button>
          <button class="tool" id="finish" type="button" title="Finish polygon">✔ Finish</button>
          <button class="tool" id="clearMeasures" type="button" title="Clear measurements">🧹 Clear</button>
        </div>
        <div class="pill pill--units" aria-label="Display units">
          <span class="small">Units</span>
          <select id="units">
            <option value="ft">ft</option>
            <option value="in">in</option>
            <option value="m">m</option>
          </select>
          <span class="small">Scale</span>
          <span id="scaleLbl" class="badge mono">–</span>
        </div>
      </div>
    </header>

    <main class="wrap wrap--compact" role="main">
      <aside class="panel" id="side">
        <section class="panel-section">
          <h3>Session</h3>
          <div class="kvs" id="sessionKVS">
            <div class="k">Status</div><div id="statusVal">Load a PDF…</div>
            <div class="k">Calibrated</div><div id="calVal" class="num">No</div>
            <div class="k">Current tool</div><div id="toolVal">Pan</div>
            <div class="k">Last length</div><div id="lenVal" class="num">–</div>
            <div class="k">Last area</div><div id="areaVal" class="num">–</div>
          </div>
        </section>

        <section class="panel-section">
          <h3>How to use</h3>
          <ol class="small instructions">
            <li>Load a PDF (use <b>Demo</b> if you like).</li>
            <li>Click <b>Calibrate</b>, pick 2 known points, enter real distance + units.</li>
            <li>Select <b>Line</b> or <b>Area</b>. Click to measure; double‑click to close a polygon.</li>
            <li>Mouse wheel = zoom. Hold <b>Space</b> and drag to pan (or use Pan tool).</li>
            <li>Use <b>Export JSON</b> to save measurements.</li>
          </ol>

          <div class="row row-spaced">
            <button class="btn secondary" id="toggleLabels">Toggle labels</button>
            <button class="btn secondary" id="toggleSnaps">Snap</button>
          </div>
          <div class="note muted-note">Snapping: end‑points & last point, useful for closing shapes cleanly.</div>
        </section>

        <section class="panel-section grow">
          <h3>Measurements</h3>
          <div id="measList" class="list small"></div>
        </section>
      </aside>

      <section class="viewer" id="viewer" aria-live="polite">
        <div class="canvas-stack" id="stack" style="display:none">
          <canvas id="pdf"></canvas>
          <canvas id="overlay"></canvas>
          <canvas id="labels"></canvas>
        </div>
        <div class="hint" id="hint">Load a PDF to begin.</div>
      </section>
    </main>
  </div>

  <!-- Calibration Modal -->
  <div class="modal" id="calModal">
    <div class="sheet">
      <h4>Set real‑world distance</h4>
      <div class="note">Pixel distance between clicks: <b><span id="pxDist" class="num"></span> px</b></div>
      <div class="row">
        <label>Distance</label>
        <input id="calValue" type="number" min="0" step="any" class="grow" placeholder="e.g. 10.5"/>
        <select id="calUnits">
          <option value="ft">ft</option>
          <option value="in">in</option>
          <option value="m">m</option>
        </select>
      </div>
      <div class="row-between" style="margin-top:.6rem">
        <button class="btn secondary" id="calCancel">Cancel</button>
        <button class="btn" id="calApply">Apply</button>
      </div>
    </div>
  </div>

  <script>
  // ====== State ======
  const state = {
    pdf: null,
    page: null,
    pageNum: 1,
    pageCount: 0,
    zoom: 1,
    minZoom: 0.2,
    maxZoom: 6,
    dpr: Math.max(1, window.devicePixelRatio || 1),
    tool: 'pan',
    units: 'ft', // display units
    unitsPerPixel: null, // null until calibrated
    calibrated: false,
    showLabels: true,
    snap: false,
    snapPoints: [],
    measures: [],
    drawing: null, // {type:'line'|'area', points:[{x,y}], temp: {x,y}}
    lastLen: null,
    lastArea: null,
  };

  // ====== DOM refs ======
  const els = {
    file: document.getElementById('file'),
    demoBtn: document.getElementById('demoBtn'),
    prev: document.getElementById('prev'),
    next: document.getElementById('next'),
    pageNum: document.getElementById('pageNum'),
    pageCount: document.getElementById('pageCount'),
    zoomIn: document.getElementById('zoomIn'),
    zoomOut: document.getElementById('zoomOut'),
    zoomReset: document.getElementById('zoomReset'),
    zoomLbl: document.getElementById('zoomLbl'),
    toolGroup: document.getElementById('toolGroup'),
    undo: document.getElementById('undo'),
    finish: document.getElementById('finish'),
    clear: document.getElementById('clearMeasures'),
    units: document.getElementById('units'),
    scaleLbl: document.getElementById('scaleLbl'),
    exportJson: document.getElementById('exportJson'),
    exportPng: document.getElementById('exportPng'),
    side: document.getElementById('side'),
    measList: document.getElementById('measList'),
    fileName: document.getElementById('fileName'),
    session: {
      status: document.getElementById('statusVal'),
      cal: document.getElementById('calVal'),
      tool: document.getElementById('toolVal'),
      len: document.getElementById('lenVal'),
      area: document.getElementById('areaVal'),
    },
    viewer: document.getElementById('viewer'),
    stack: document.getElementById('stack'),
    pdf: document.getElementById('pdf'),
    overlay: document.getElementById('overlay'),
    labels: document.getElementById('labels'),
    hint: document.getElementById('hint'),
    toggleLabels: document.getElementById('toggleLabels'),
    toggleSnaps: document.getElementById('toggleSnaps'),
    // Modal
    calModal: document.getElementById('calModal'),
    pxDist: document.getElementById('pxDist'),
    calValue: document.getElementById('calValue'),
    calUnits: document.getElementById('calUnits'),
    calApply: document.getElementById('calApply'),
    calCancel: document.getElementById('calCancel'),
  };

  const ctxs = {
    pdf: els.pdf.getContext('2d'),
    overlay: els.overlay.getContext('2d'),
    labels: els.labels.getContext('2d')
  };

  const overlayStyles = {
    stroke: 'rgba(111, 182, 255, 0.95)',
    areaFill: 'rgba(130, 224, 170, 0.22)',
    guide: 'rgba(255, 255, 255, 0.35)',
    bubble: 'rgba(0, 0, 0, 0.55)',
    bubbleText: '#e7ecf3'
  };

  function roundRect(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r);
    ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
    ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r);
    ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y);
    ctx.closePath();
  }

  // ====== Helpers ======
  function fmtLen(value, units){
    if(value == null || !isFinite(value)) return '–';
    const u = units || state.units;
    let v = value;
    // For feet display, show ft+in when appropriate
    if(u==='ft'){
      const inches = v*12;
      if(inches < 24) return inches.toFixed(2) + ' in';
      const ft = Math.floor(v);
      const remIn = (v-ft)*12;
      return ft + '′ ' + remIn.toFixed(1) + '″';
    }
    if(u==='in') return v.toFixed(2) + ' in';
    if(u==='m'){
      if(v<1) return (v*100).toFixed(1) + ' cm';
      return v.toFixed(3) + ' m';
    }
    return v.toFixed(2) + ' ' + u;
  }
  function fmtArea(value, units){
    if(value == null || !isFinite(value)) return '–';
    const u = units || state.units;
    if(u==='ft') return value.toFixed(2) + ' ft²';
    if(u==='in') return value.toFixed(0) + ' in²';
    if(u==='m'){
      if(value<1) return (value*10000).toFixed(1) + ' cm²';
      return value.toFixed(3) + ' m²';
    }
    return value.toFixed(2) + ' ' + u + '²';
  }
  function unitsToBaseFactor(u){
    // Return factor to convert from chosen units to base units (feet and meters are allowed base)
    // We'll use feet as imperial base for display convenience
    if(u==='ft') return 1;
    if(u==='in') return 1/12; // inches -> feet
    if(u==='m') return 3.280839895; // meters -> feet
    return 1;
  }
  function fromBaseToUnitsFactor(u){
    if(u==='ft') return 1;
    if(u==='in') return 12;
    if(u==='m') return 0.3048; // feet -> meters
    return 1;
  }
  function worldPerPixel(){
    // returns feet per pixel (base unit feet) if calibrated; else null
    return state.unitsPerPixel; // in feet per px
  }
  function lenPxToWorld(px){
    const fpp = worldPerPixel();
    if(!fpp) return null;
    const ft = px * fpp; // feet
    return ft * fromBaseToUnitsFactor(state.units);
  }
  function areaPxToWorld(px2){
    const fpp = worldPerPixel();
    if(!fpp) return null;
    const ft2 = px2 * fpp * fpp; // square feet
    const u = state.units;
    if(u==='ft') return ft2;
    if(u==='in') return ft2 * 144; // 12^2
    if(u==='m') return ft2 * 0.09290304; // ft2->m2
    return ft2;
  }
  function dist(a,b){
    const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy);
  }
  function centroid(points){
    let x=0,y=0; for(const p of points){x+=p.x;y+=p.y} return {x:x/points.length,y:y/points.length};
  }
  function polygonAreaPx(points){
    let a=0; for(let i=0,j=points.length-1;i<points.length;j=i++){
      const p=points[i], q=points[j]; a += (q.x+p.x)*(q.y-p.y);
    } return Math.abs(a/2);
  }
  function polygonPerimeterPx(points){
    let s=0; for(let i=0;i<points.length;i++){ s+=dist(points[i], points[(i+1)%points.length]); } return s;
  }
  function refreshSnapPoints(){
    const pts = [];
    for(const m of state.measures){
      if(m.type==='line'){
        pts.push(m.a, m.b);
      } else if(m.type==='area'){
        pts.push(...m.points);
      }
    }
    state.snapPoints = pts;
  }

  function setStatus(txt){ els.session.status.textContent = txt; }
  function setTool(name){
    state.tool = name; els.session.tool.textContent = name.charAt(0).toUpperCase()+name.slice(1);
    for(const b of els.toolGroup.querySelectorAll('.tool[data-tool]')) b.classList.toggle('active', b.dataset.tool===name);
  }
  function updateScaleLabel(){
    if(!state.calibrated || !state.unitsPerPixel){ els.scaleLbl.textContent = 'not set'; return; }
    // Show as: 1 px = X units
    const baseFtPerPx = state.unitsPerPixel; // feet/px
    const val = baseFtPerPx * fromBaseToUnitsFactor(state.units);
    const u = state.units;
    let label = `1 px = ${u==='m'?val.toFixed(6):val.toFixed(4)} ${u}`;
    els.scaleLbl.textContent = label;
    els.session.cal.textContent = 'Yes';
  }

  // ====== PDF Rendering ======
  let renderTask = null;
  async function loadPDF(data){
    try{
      state.pdf = await pdfjsLib.getDocument(data).promise;
      state.pageCount = state.pdf.numPages; els.pageCount.textContent = state.pageCount;
      state.pageNum = 1; els.pageNum.textContent = 1;
      setStatus('PDF loaded');
      await renderPage();
    }catch(e){
      console.error(e); setStatus('Failed to load PDF');
      if(els.fileName) els.fileName.textContent = 'No document loaded';
    }
  }
  async function renderPage(){
    if(!state.pdf) return;
    if(renderTask) {
      try{
        await renderTask.cancel();
      }catch{}
      renderTask = null;
    }
    const page = await state.pdf.getPage(state.pageNum);
    state.page = page;
    const viewport = page.getViewport({ scale: state.zoom * state.dpr });
    const canvas = els.pdf, ctx = ctxs.pdf;
    canvas.width = Math.ceil(viewport.width);
    canvas.height = Math.ceil(viewport.height);
    canvas.style.width = (viewport.width / state.dpr) + 'px';
    canvas.style.height = (viewport.height / state.dpr) + 'px';

    // Overlay & label canvases follow same size
    for(const c of [els.overlay, els.labels]){
      c.width = canvas.width; c.height = canvas.height;
      c.style.width = canvas.style.width; c.style.height = canvas.style.height;
    }

    els.stack.style.display = 'inline-block';
    els.hint.style.display = 'none';

    const renderCtx = { canvasContext: ctx, viewport };
    renderTask = page.render(renderCtx);
    await renderTask.promise;
    renderTask = null;
    drawOverlay();
    updateZoomLbl();
  }

  function updateZoomLbl(){ els.zoomLbl.textContent = Math.round(state.zoom*100) + '%'; }

  function setZoom(z, around){
    const scroller = els.viewer;
    const oldZoom = state.zoom;
    z = Math.max(state.minZoom, Math.min(state.maxZoom, z));
    if(!state.page || z===oldZoom) return;

    // Keep point under cursor stable
    let cx=0, cy=0; let sx=0, sy=0;
    if(around){
      const rect = els.pdf.getBoundingClientRect();
      cx = (around.clientX - rect.left) * (els.pdf.width / rect.width);
      cy = (around.clientY - rect.top) * (els.pdf.height / rect.height);
      sx = (around.clientX + scroller.scrollLeft - rect.left);
      sy = (around.clientY + scroller.scrollTop - rect.top);
    }

    state.zoom = z;
    renderPage().then(()=>{
      if(around){
        const rect = els.pdf.getBoundingClientRect();
        const nx = cx / (els.pdf.width / rect.width);
        const ny = cy / (els.pdf.height / rect.height);
        scroller.scrollLeft = nx - sx + scroller.scrollLeft;
        scroller.scrollTop = ny - sy + scroller.scrollTop;
      }
    });
  }

  // ====== Overlay Drawing ======
  function overlayScale(){
    // pixels per CSS pixel
    const rectW = els.overlay.clientWidth || 1; // CSS px
    return els.overlay.width / rectW; // device pixels per CSS px
  }
  function clientToCanvas(ev){
    const rect = els.overlay.getBoundingClientRect();
    const xCss = ev.clientX - rect.left, yCss = ev.clientY - rect.top;
    const k = overlayScale();
    return { x: xCss * k, y: yCss * k };
  }
  function snapIfNeeded(p){
    if(!state.snap) return p;
    const pts = state.snapPoints.slice();
    if(state.drawing && state.drawing.points.length){
      const last = state.drawing.points[state.drawing.points.length-1];
      pts.push(last, state.drawing.points[0]);
    }
    let best=p, bestD=8*state.dpr; // 8px radius snap
    for(const q of pts){ const d=dist(p,q); if(d<bestD){ best=q; bestD=d; } }
    return best;
  }

  function drawOverlay(){
    const o = ctxs.overlay; const l = ctxs.labels;
    o.clearRect(0,0,els.overlay.width,els.overlay.height);
    l.clearRect(0,0,els.labels.width,els.labels.height);

    // Draw existing measures
    for(const m of state.measures){
      if(m.type==='line'){
        o.save();
        o.lineWidth = 2*state.dpr;
        o.lineCap='round';
        o.lineJoin='round';
        o.strokeStyle = overlayStyles.stroke;
        o.beginPath(); o.moveTo(m.a.x,m.a.y); o.lineTo(m.b.x,m.b.y); o.stroke();
        o.restore();
        if(state.showLabels){
          const mid = {x:(m.a.x+m.b.x)/2, y:(m.a.y+m.b.y)/2};
          const lenWorld = lenPxToWorld(m.lengthPx);
          const text = fmtLen(lenWorld);
          drawLabel(mid.x, mid.y, text);
        }
      } else if(m.type==='area'){
        o.save();
        o.lineWidth = 2*state.dpr;
        o.lineCap='round';
        o.lineJoin='round';
        o.strokeStyle = overlayStyles.stroke;
        o.fillStyle = overlayStyles.areaFill;
        o.beginPath(); m.points.forEach((p,i)=> i?o.lineTo(p.x,p.y):o.moveTo(p.x,p.y)); o.closePath(); o.fill(); o.stroke();
        o.restore();
        if(state.showLabels){
          const c = centroid(m.points);
          const areaWorld = areaPxToWorld(m.areaPx2);
          const perWorld = lenPxToWorld(m.perimeterPx);
          drawLabel(c.x,c.y, `${fmtArea(areaWorld)}  (P: ${fmtLen(perWorld)})`);
        }
      }
    }

    // Draw current drawing
    if(state.drawing){
      const d = state.drawing;
      if(d.type==='line' && d.points.length){
        o.save();
        o.setLineDash([6*state.dpr,6*state.dpr]);
        o.strokeStyle = overlayStyles.guide;
        o.lineWidth = 1.5*state.dpr;
        const a = d.points[0]; const b = d.temp || a;
        o.beginPath(); o.moveTo(a.x,a.y); o.lineTo(b.x,b.y); o.stroke();
        o.restore();
        const len = lenPxToWorld(dist(a,b));
        if(len!=null && state.showLabels) drawLabel((a.x+b.x)/2,(a.y+b.y)/2, fmtLen(len));
      }
      if(d.type==='area' && d.points.length){
        o.save();
        o.setLineDash([6*state.dpr,6*state.dpr]);
        o.strokeStyle = overlayStyles.guide;
        o.lineWidth = 1.5*state.dpr;
        o.beginPath(); d.points.forEach((p,i)=> i?o.lineTo(p.x,p.y):o.moveTo(p.x,p.y));
        if(d.temp){ o.lineTo(d.temp.x, d.temp.y); }
        o.stroke(); o.restore();
        if(state.showLabels && d.points.length>=2 && d.temp){
          const pts = d.points.concat([d.temp]);
          const aPx = polygonAreaPx(pts); const aW = areaPxToWorld(aPx);
          const c = centroid(pts);
          drawLabel(c.x,c.y, fmtArea(aW));
        }
      }
    }

    function drawLabel(x,y,text){
      const pad = 6*state.dpr; const r = 6*state.dpr;
      l.save();
      l.font = `${12*state.dpr}px ui-sans-serif,system-ui,Segoe UI,Roboto`;
      const metrics = l.measureText(text);
      const w = metrics.width + pad*2, h = 20*state.dpr;
      const bx = x - w/2, by = y - h - 8*state.dpr;
      // bubble
      l.fillStyle = overlayStyles.bubble;
      roundRect(l, bx,by,w,h,r); l.fill();
      // text
      l.fillStyle = overlayStyles.bubbleText;
      l.fillText(text, bx+pad, by+14*state.dpr);
      l.restore();
    }
  }

  // ====== Interactions ======
  // File loading
  els.file.addEventListener('change', async (e)=>{
    const f = e.target.files[0];
    if(!f) return;
    if(els.fileName) els.fileName.textContent = f.name;
    setStatus('Loading…');
    const buf = await f.arrayBuffer();
    loadPDF({data: buf});
  });

  // Demo document (simple single-page grid created on the fly)
  els.demoBtn.addEventListener('click', async ()=>{
    if(els.fileName) els.fileName.textContent = 'Sample demo plan.pdf';
    // Fetch a tiny embedded PDF (data URL) for demo
    // For portability, generate on the fly using a prebuilt minimal PDF string
    const pdfData = atob("JVBERi0xLjMKJcTl8uXrp/Og0MTGCjEgMCBvYmoKPDwKL1R5cGUgL1BhZ2UKL1BhcmVudCAyIDAgUgovUmVzb3VyY2VzIDw8Ci9Qcm9jU2V0IFsvUERGL1RleHRdCi9Gb250IDw8Ci9GMCAzIDAgUgo+PgovWE9iamVjdCA8PC9JbWFnZSA8PC9XaWR0aCA2MDAvSGVpZ2h0IDg0MC9Db2xvclNwYWNlIC9EZXZpY2VSR0IvQml0c1BlckNvbXBvbmVudCA4Pj4+PgovRXh0R1N0YXRlIDw8Pj4+PgovTWVkaWFCb3hbMCAwIDU5NSA4MzVdCi9Db250ZW50cyA0IDAgUgo+PgplbmRvYmoKMiAwIG9iago8PAovVHlwZSAvUGFnZXMKL0tpZHMgWyAxIDAgUiBdCi9Db3VudCAxCj4+CmVuZG9iagozIDAgb2JqCjw8Ci9UeXBlIC9Gb250Ci9TdWJ0eXBlIC9UeXBlMQovTmFtZSAvRjAKL0Jhc2VGb250IC9IZWx2ZXRpY2EKL0VuY29kaW5nIC9XaW5BbnNpRW5jb2RpbmcKPj4KZW5kb2JqCjQgMCBvYmoKPDwKL0xlbmd0aCAyMDY+PgpzdHJlYW0KQlQKIC9GMCBUIDEyIFRmCiAgMCA3ODAgVGQKICAoR2VuZXJhdGVkIERlbW8gR3JpZCBGb3IgTWVhc3VyZW1lbnQpIFRqCkJUCiAgL0YwIFQgMTIgVGYKICAxMDAgNzEwIFRkCiAgKDIwIGZ0IG1ham9yIGdyaWQ6IGVhY2ggcXVhcmUgaXMgMSBmdClUagpCVApFcwpRVQplbmRzdHJlYW0KZW5kb2JqCnhyZWYKMCA3CjAwMDAwMDAwMDAgNjU1MzUgZiAKMDAwMDAwMDEwMCAwMDAwMCBuIAowMDAwMDAwMDg3IDAwMDAwIG4gCjAwMDAwMDAxODIgMDAwMDAgbiAKMDAwMDAwMDMxMSAwMDAwMCBuIAowMDAwMDAwNTE5IDAwMDAwIG4gCnRyYWlsZXIKPDwKL1NpemUgNwo+PgpzdGFydHhyZWYKNTM3CiUlRU9G");
    const bytes = new Uint8Array(pdfData.length);
    for(let i=0;i<pdfData.length;i++) bytes[i]=pdfData.charCodeAt(i);
    await loadPDF({data: bytes});
  });

  // Paging
  els.prev.addEventListener('click', ()=>{ if(!state.pdf) return; state.pageNum=Math.max(1,state.pageNum-1); els.pageNum.textContent=state.pageNum; renderPage(); });
  els.next.addEventListener('click', ()=>{ if(!state.pdf) return; state.pageNum=Math.min(state.pageCount,state.pageNum+1); els.pageNum.textContent=state.pageNum; renderPage(); });

  // Zoom
  els.zoomIn.addEventListener('click', ()=> setZoom(state.zoom*1.2));
  els.zoomOut.addEventListener('click', ()=> setZoom(state.zoom/1.2));
  els.zoomReset.addEventListener('click', ()=> setZoom(1));
  els.viewer.addEventListener('wheel', (e)=>{
    if(!e.ctrlKey && !e.metaKey){ return; } // use ctrl/cmd+wheel to zoom for accessibility
    e.preventDefault();
    const delta = e.deltaY<0 ? 1.12 : (1/1.12);
    setZoom(state.zoom*delta, e);
  }, {passive:false});

  // Tool select
  els.toolGroup.addEventListener('click', (e)=>{
    const b = e.target.closest('[data-tool]'); if(!b) return;
    setTool(b.dataset.tool);
  });

  // Units
  els.units.addEventListener('change', ()=>{ state.units = els.units.value; updateScaleLabel(); drawOverlay(); });

  // Toggle labels/snaps
  els.toggleLabels.addEventListener('click', ()=>{ state.showLabels=!state.showLabels; drawOverlay(); });
  els.toggleSnaps.addEventListener('click', ()=>{ state.snap=!state.snap; els.toggleSnaps.classList.toggle('ghost', !state.snap); });

  // Overlay pointer events
  let isPanning=false; let panStart={x:0,y:0,sl:0,st:0}; let spaceHeld=false;
  window.addEventListener('keydown', (e)=>{ if(e.code==='Space') { spaceHeld=true; } if(e.key==='Enter') finishPolygon(); });
  window.addEventListener('keyup', (e)=>{ if(e.code==='Space') spaceHeld=false; });

  els.overlay.addEventListener('mousedown', (e)=>{
    if(!state.page) return;
    const p = snapIfNeeded(clientToCanvas(e));
    const effectiveTool = (spaceHeld? 'pan' : state.tool);
    if(effectiveTool==='pan' || e.button===1){ // middle mouse pan too
      isPanning=true; const sc=els.viewer; panStart={x:e.clientX,y:e.clientY,sl:sc.scrollLeft,st:sc.scrollTop};
      return;
    }
    if(effectiveTool==='calibrate') handleCalibrateClick(p);
    if(effectiveTool==='line') handleLineClick(p);
    if(effectiveTool==='area') handleAreaClick(p);
  });
  els.overlay.addEventListener('mousemove', (e)=>{
    if(isPanning){ const sc=els.viewer; sc.scrollLeft = panStart.sl - (e.clientX-panStart.x); sc.scrollTop = panStart.st - (e.clientY-panStart.y); return; }
    if(!state.page) return;
    const p = snapIfNeeded(clientToCanvas(e));
    if(state.drawing){ state.drawing.temp = p; drawOverlay(); }
  });
  window.addEventListener('mouseup', ()=>{ isPanning=false; });
  els.overlay.addEventListener('dblclick', ()=> finishPolygon());

  // Undo / Finish / Clear
  els.undo.addEventListener('click', ()=>{
    if(state.drawing && state.drawing.points.length){ state.drawing.points.pop(); state.drawing.temp=null; drawOverlay(); }
  });
  function finishPolygon(){
    if(state.drawing && state.drawing.type==='area' && state.drawing.points.length>=3){
      const pts = state.drawing.points.slice();
      const areaPx2 = polygonAreaPx(pts);
      const perPx = polygonPerimeterPx(pts);
      state.lastArea = areaPxToWorld(areaPx2); els.session.area.textContent = fmtArea(state.lastArea);
      state.drawing = null;
      addMeasure({type:'area', points:pts, areaPx2, perimeterPx: perPx});
    }
  }
  els.finish.addEventListener('click', finishPolygon);

  els.clear.addEventListener('click', ()=>{
    state.measures = []; state.drawing=null; state.lastLen=null; state.lastArea=null; els.session.len.textContent='–'; els.session.area.textContent='–'; refreshSnapPoints(); drawOverlay(); refreshList();
  });

  // Export
  els.exportJson.addEventListener('click', ()=>{
    const out = state.measures.map((m,i)=>{
      if(m.type==='line'){
        return { id:`L${i+1}`, type:'line', a:m.a, b:m.b, length_px:m.lengthPx, length_units: lenPxToWorld(m.lengthPx), units: state.units };
      }else{
        return { id:`A${i+1}`, type:'area', points:m.points, area_px2: m.areaPx2, area_units: areaPxToWorld(m.areaPx2), perimeter_units: lenPxToWorld(m.perimeterPx), units: state.units };
      }
    });
    const blob = new Blob([JSON.stringify(out,null,2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download='measurements.json'; a.click(); setTimeout(()=>URL.revokeObjectURL(url), 5000);
  });

  els.exportPng.addEventListener('click', ()=>{
    // Compose PDF canvas + overlay + labels into a single PNG for quick snapshot
    if(!state.page) return;
    const w = els.pdf.width, h=els.pdf.height;
    const cnv = document.createElement('canvas'); cnv.width=w; cnv.height=h; const c=cnv.getContext('2d');
    c.drawImage(els.pdf,0,0); c.drawImage(els.overlay,0,0); c.drawImage(els.labels,0,0);
    cnv.toBlob(b=>{ const url = URL.createObjectURL(b); const a=document.createElement('a'); a.href=url; a.download='snapshot.png'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),5000); }, 'image/png');
  });

  // ====== Measurement handlers ======
  // Calibration
  let calClicks = [];
  function handleCalibrateClick(p){
    calClicks.push(p);
    if(calClicks.length===2){
      const px = dist(calClicks[0], calClicks[1]);
      els.pxDist.textContent = px.toFixed(2);
      els.calUnits.value = state.units; els.calValue.value = '';
      openCalModal(px);
      calClicks = [];
    } else {
      drawOverlay();
    }
  }
  function openCalModal(px){ els.calModal.style.display='flex'; els.calApply.onclick = ()=>applyCalibration(px); els.calCancel.onclick = closeCalModal; }
  function closeCalModal(){ els.calModal.style.display='none'; }
  function applyCalibration(px){
    const value = parseFloat(els.calValue.value);
    const u = els.calUnits.value;
    if(!(value>0)) { alert('Enter a valid distance'); return; }
    const inFeet = value * unitsToBaseFactor(u); // feet
    state.unitsPerPixel = inFeet / px; // feet per pixel
    state.calibrated = true; closeCalModal();
    updateScaleLabel(); setStatus('Calibration set'); drawOverlay();
  }

  // Line measurement
  function handleLineClick(p){
    if(!state.calibrated){ alert('Please calibrate first.'); return; }
    if(!state.drawing){ state.drawing = {type:'line', points:[p], temp:null}; }
    else if(state.drawing.type==='line' && state.drawing.points.length===1){
      const a = state.drawing.points[0]; const b = p;
      const Lpx = dist(a,b);
      state.lastLen = lenPxToWorld(Lpx); els.session.len.textContent = fmtLen(state.lastLen);
      state.drawing = null;
      addMeasure({type:'line', a,b, lengthPx:Lpx});
    }
  }

  // Area measurement
  function handleAreaClick(p){
    if(!state.calibrated){ alert('Please calibrate first.'); return; }
    if(!state.drawing){ state.drawing = {type:'area', points:[p], temp:null}; drawOverlay(); return; }
    if(state.drawing.type==='area'){ state.drawing.points.push(p); drawOverlay(); }
  }

  // List UI
  function addMeasure(measure){
    state.measures.push(measure);
    refreshSnapPoints();
    drawOverlay();
    refreshList();
  }

  function refreshList(){
    els.measList.innerHTML = '';
    state.measures.forEach((m,i)=>{
      const div = document.createElement('div');
      const id = (m.type==='line'?'L':'A') + (i+1);
      if(m.type==='line'){
        const len = lenPxToWorld(m.lengthPx);
        div.innerHTML = `<div class="row-between"><div><b>${id}</b> · Line</div><div class="mono">${fmtLen(len)}</div></div>`;
      } else {
        const a = areaPxToWorld(m.areaPx2); const p = lenPxToWorld(m.perimeterPx);
        div.innerHTML = `<div class="row-between"><div><b>${id}</b> · Area</div><div class="mono">${fmtArea(a)} · P ${fmtLen(p)}</div></div>`;
      }
      els.measList.appendChild(div);
    });
  }

  // ====== Init defaults ======
  refreshSnapPoints();
  els.toggleSnaps.classList.toggle('ghost', !state.snap);
  setTool('pan'); updateScaleLabel(); updateZoomLbl();

  </script>
</body>
</html>
